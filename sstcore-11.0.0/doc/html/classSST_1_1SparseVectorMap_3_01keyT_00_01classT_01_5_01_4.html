<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>SST: SST::SparseVectorMap&lt; keyT, classT * &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SST
   &#160;<span id="projectnumber">11.0.0</span>
   </div>
   <div id="projectbrief">StructuralSimulationToolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SST::SparseVectorMap&lt; keyT, classT * &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that stores data in a vector, but can access the data similar to a map.  
 <a href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparseVectorMap_8h_source.html">sparseVectorMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8fe6a3efa6a4d8db4ab35a5f72f0ac73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe6a3efa6a4d8db4ab35a5f72f0ac73"></a>
typedef std::vector&lt; classT * &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a8fe6a3efa6a4d8db4ab35a5f72f0ac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eaf09ac8383eee6d69b7eb7eaed0fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98eaf09ac8383eee6d69b7eb7eaed0fb"></a>
typedef std::vector&lt; classT * &gt;<br class="typebreak"/>
::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a98eaf09ac8383eee6d69b7eb7eaed0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a862c1857507c80d4bf4eb37095051fbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a862c1857507c80d4bf4eb37095051fbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a862c1857507c80d4bf4eb37095051fbe">SparseVectorMap</a> ()</td></tr>
<tr class="memdesc:a862c1857507c80d4bf4eb37095051fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. <br/></td></tr>
<tr class="separator:a862c1857507c80d4bf4eb37095051fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed39d010c3746d30704a56277341575"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a3ed39d010c3746d30704a56277341575">SparseVectorMap</a> (std::vector&lt; classT * &gt; &amp;new_data, bool sorted=false)</td></tr>
<tr class="memdesc:a3ed39d010c3746d30704a56277341575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows you to pass an already filled in array with data.  <a href="#a3ed39d010c3746d30704a56277341575">More...</a><br/></td></tr>
<tr class="separator:a3ed39d010c3746d30704a56277341575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b536563cec2bcbd4c643111c084024"><td class="memItemLeft" align="right" valign="top">classT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a54b536563cec2bcbd4c643111c084024">insert</a> (classT *val)</td></tr>
<tr class="memdesc:a54b536563cec2bcbd4c643111c084024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new value into <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#a54b536563cec2bcbd4c643111c084024">More...</a><br/></td></tr>
<tr class="separator:a54b536563cec2bcbd4c643111c084024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9d2fb39d9d039096ccf73cafa5c1da"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a2f9d2fb39d9d039096ccf73cafa5c1da">begin</a> ()</td></tr>
<tr class="memdesc:a2f9d2fb39d9d039096ccf73cafa5c1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the begin iterator to the underlying vector.  <a href="#a2f9d2fb39d9d039096ccf73cafa5c1da">More...</a><br/></td></tr>
<tr class="separator:a2f9d2fb39d9d039096ccf73cafa5c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f1e5da230e6ae09fb95899f7acf58"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a294f1e5da230e6ae09fb95899f7acf58">end</a> ()</td></tr>
<tr class="memdesc:a294f1e5da230e6ae09fb95899f7acf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end iterator to the underlying vector.  <a href="#a294f1e5da230e6ae09fb95899f7acf58">More...</a><br/></td></tr>
<tr class="separator:a294f1e5da230e6ae09fb95899f7acf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c319aee9c2284ff818cc6834b9ea4e3"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a5c319aee9c2284ff818cc6834b9ea4e3">begin</a> () const </td></tr>
<tr class="memdesc:a5c319aee9c2284ff818cc6834b9ea4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const begin iterator to the underlying vector.  <a href="#a5c319aee9c2284ff818cc6834b9ea4e3">More...</a><br/></td></tr>
<tr class="separator:a5c319aee9c2284ff818cc6834b9ea4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfe4cc387c0ff46892a8d59ea7cf3b0"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#afdfe4cc387c0ff46892a8d59ea7cf3b0">end</a> () const </td></tr>
<tr class="memdesc:afdfe4cc387c0ff46892a8d59ea7cf3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const end iterator to the underlying vector.  <a href="#afdfe4cc387c0ff46892a8d59ea7cf3b0">More...</a><br/></td></tr>
<tr class="separator:afdfe4cc387c0ff46892a8d59ea7cf3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f34e17f1719618b23a08dbeba333ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#ac6f34e17f1719618b23a08dbeba333ce">contains</a> (keyT id) const </td></tr>
<tr class="memdesc:ac6f34e17f1719618b23a08dbeba333ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided id is found in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#ac6f34e17f1719618b23a08dbeba333ce">More...</a><br/></td></tr>
<tr class="separator:ac6f34e17f1719618b23a08dbeba333ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8007007f1b619170698f2b20856040"><td class="memItemLeft" align="right" valign="top">classT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a7a8007007f1b619170698f2b20856040">operator[]</a> (keyT id)</td></tr>
<tr class="memdesc:a7a8007007f1b619170698f2b20856040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator returns a reference to data with the specified id.  <a href="#a7a8007007f1b619170698f2b20856040">More...</a><br/></td></tr>
<tr class="separator:a7a8007007f1b619170698f2b20856040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7800fc78998c3c8f52b972d0f8432"><td class="memItemLeft" align="right" valign="top">const classT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#ad7d7800fc78998c3c8f52b972d0f8432">operator[]</a> (keyT id) const </td></tr>
<tr class="memdesc:ad7d7800fc78998c3c8f52b972d0f8432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator returns a const reference to data with the specified id.  <a href="#ad7d7800fc78998c3c8f52b972d0f8432">More...</a><br/></td></tr>
<tr class="separator:ad7d7800fc78998c3c8f52b972d0f8432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5b25dcd9edfbcbba2328346278fcd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f5b25dcd9edfbcbba2328346278fcd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a4f5b25dcd9edfbcbba2328346278fcd8">clear</a> ()</td></tr>
<tr class="memdesc:a4f5b25dcd9edfbcbba2328346278fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. <br/></td></tr>
<tr class="separator:a4f5b25dcd9edfbcbba2328346278fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf2002dcf9c7479f1ed8f8ddacd0559"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a0bf2002dcf9c7479f1ed8f8ddacd0559">size</a> ()</td></tr>
<tr class="memdesc:a0bf2002dcf9c7479f1ed8f8ddacd0559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>.  <a href="#a0bf2002dcf9c7479f1ed8f8ddacd0559">More...</a><br/></td></tr>
<tr class="separator:a0bf2002dcf9c7479f1ed8f8ddacd0559"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af0942ca5bb3e6045d03ee3c722f673b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0942ca5bb3e6045d03ee3c722f673b8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SST::Core::Serialization::serialize&lt; SparseVectorMap&lt; keyT, classT * &gt; &gt;</b></td></tr>
<tr class="separator:af0942ca5bb3e6045d03ee3c722f673b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeae9ced43d2d1dea9eea33bd767ca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbeae9ced43d2d1dea9eea33bd767ca9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConfigGraph</b></td></tr>
<tr class="separator:acbeae9ced43d2d1dea9eea33bd767ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename keyT, typename classT&gt;<br/>
class SST::SparseVectorMap&lt; keyT, classT * &gt;</h3>

<p>Class that stores data in a vector, but can access the data similar to a map. </p>
<p>The data structure is O(log n) on reads, but is O(n) to insert. The primary use case is when data is inserted in order, but accessed randomly. You can also create the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a> with a vector already loaded with the data. If the data is not already sorted, it will call std::sort on the data, which likely has an average complexity of O(n log n). This data structure should not be used for large lists where inserts do not happen in sorted order.</p>
<p>NOTE: Since the data is stored in the vector, reference returned from the various accessor functions will not be valid longterm. If an insert causes the vector to be resized, all references returned before that reallocation may (likely will) be invalid. References are only guaranteed to be valid until the next write to the data structure. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3ed39d010c3746d30704a56277341575"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::<a class="el" href="classSST_1_1SparseVectorMap.html">SparseVectorMap</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; classT * &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that allows you to pass an already filled in array with data. </p>
<p>The data in the passed in vector will be swapped into the data vector of the sparsevectormap and the passed in vector will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data</td><td>Vector of data to swap into the sparsevectormap data</td></tr>
    <tr><td class="paramname">sorted</td><td>Specifies whether the vector is already sorted in ascending order. if not, it will be sorted after swapping the data in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f9d2fb39d9d039096ccf73cafa5c1da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the begin iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>begin iterator to data vector </dd></dl>

</div>
</div>
<a class="anchor" id="a5c319aee9c2284ff818cc6834b9ea4e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the const begin iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>const begin iterator to data vector </dd></dl>

</div>
</div>
<a class="anchor" id="ac6f34e17f1719618b23a08dbeba333ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">keyT&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the provided id is found in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if id is found, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a294f1e5da230e6ae09fb95899f7acf58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the end iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>end iterator to data vector </dd></dl>

</div>
</div>
<a class="anchor" id="afdfe4cc387c0ff46892a8d59ea7cf3b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the const end iterator to the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>const end iterator to data vector </dd></dl>

</div>
</div>
<a class="anchor" id="a54b536563cec2bcbd4c643111c084024"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">classT* <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">classT *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new value into <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<p>The inserted class must have a key() function with return type keyT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to add to <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the inserted item, or to the existing item if it was already present in the map. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a8007007f1b619170698f2b20856040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">classT* <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">keyT&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator returns a reference to data with the specified id. </p>
<p>Value can be modified. This will only return references to existing values, you must use <a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a54b536563cec2bcbd4c643111c084024" title="Insert new value into SparseVectorMap. ">insert()</a> for new values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of the value to return (value returned by key())</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the requested item. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7d7800fc78998c3c8f52b972d0f8432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const classT* <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">keyT&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator returns a const reference to data with the specified id. </p>
<p>Value cannot be modified. This will only return references to existing values, you must use <a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html#a54b536563cec2bcbd4c643111c084024" title="Insert new value into SparseVectorMap. ">insert()</a> for new values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of the value to return (value returned by key())</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to the requested item. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf2002dcf9c7479f1ed8f8ddacd0559"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyT , typename classT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSST_1_1SparseVectorMap.html">SST::SparseVectorMap</a>&lt; keyT, classT * &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in the <a class="el" href="classSST_1_1SparseVectorMap.html" title="Class that stores data in a vector, but can access the data similar to a map. ">SparseVectorMap</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>number of items </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/sst/core/<a class="el" href="sparseVectorMap_8h_source.html">sparseVectorMap.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>SST</b></li><li class="navelem"><a class="el" href="classSST_1_1SparseVectorMap_3_01keyT_00_01classT_01_5_01_4.html">SparseVectorMap< keyT, classT * ></a></li>
    <li class="footer">Generated on Mon May 3 2021 09:45:08 for SST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
