<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>SST: SST::Params Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SST
   &#160;<span id="projectnumber">11.0.0</span>
   </div>
   <div id="projectbrief">StructuralSimulationToolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSST_1_1Params.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SST::Params Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parameter store.  
 <a href="classSST_1_1Params.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="params_8h_source.html">params.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SST::Params:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSST_1_1Params.png" usemap="#SST::Params_map" alt=""/>
  <map id="SST::Params_map" name="SST::Params_map">
<area href="classSST_1_1Core_1_1Serialization_1_1serializable.html" alt="SST::Core::Serialization::serializable" shape="rect" coords="0,0,214,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1becebbd2a5e743425c52699a888285d"><td class="memItemLeft" align="right" valign="top">typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a></td></tr>
<tr class="separator:a1becebbd2a5e743425c52699a888285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6800309a3de9d1c6ca038788cdd9af"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a>, <br class="typebreak"/>
KeyCompare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#aca6800309a3de9d1c6ca038788cdd9af">KeySet_t</a></td></tr>
<tr class="separator:aca6800309a3de9d1c6ca038788cdd9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5078fe8ed23d69bc278f7cdd3414a06f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a5078fe8ed23d69bc278f7cdd3414a06f">enableVerify</a> (bool enable)</td></tr>
<tr class="memdesc:a5078fe8ed23d69bc278f7cdd3414a06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable parameter verification on an instance of <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a>.  <a href="#a5078fe8ed23d69bc278f7cdd3414a06f">More...</a><br/></td></tr>
<tr class="separator:a5078fe8ed23d69bc278f7cdd3414a06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1177506a58aa634ad786333da58aaf61"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a1177506a58aa634ad786333da58aaf61">size</a> () const </td></tr>
<tr class="memdesc:a1177506a58aa634ad786333da58aaf61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a>.  <a href="#a1177506a58aa634ad786333da58aaf61">More...</a><br/></td></tr>
<tr class="separator:a1177506a58aa634ad786333da58aaf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a75c3571c53b300facb15c120bb551c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a2a75c3571c53b300facb15c120bb551c">empty</a> () const </td></tr>
<tr class="memdesc:a2a75c3571c53b300facb15c120bb551c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> is empty.  <a href="#a2a75c3571c53b300facb15c120bb551c">More...</a><br/></td></tr>
<tr class="separator:a2a75c3571c53b300facb15c120bb551c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637c16536169ee8e0dd5fdf3e8efa23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3637c16536169ee8e0dd5fdf3e8efa23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a3637c16536169ee8e0dd5fdf3e8efa23">Params</a> ()</td></tr>
<tr class="memdesc:a3637c16536169ee8e0dd5fdf3e8efa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a>. <br/></td></tr>
<tr class="separator:a3637c16536169ee8e0dd5fdf3e8efa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c6214cd0d78e69d3734a77da5a9a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c6214cd0d78e69d3734a77da5a9a14"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#ad7c6214cd0d78e69d3734a77da5a9a14">Params</a> (const <a class="el" href="classSST_1_1Params.html">Params</a> &amp;old)</td></tr>
<tr class="memdesc:ad7c6214cd0d78e69d3734a77da5a9a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of a <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object. <br/></td></tr>
<tr class="separator:ad7c6214cd0d78e69d3734a77da5a9a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3410d5df67dd4c00366caa45a4db2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSST_1_1Params.html">Params</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a5c3410d5df67dd4c00366caa45a4db2d">operator=</a> (const <a class="el" href="classSST_1_1Params.html">Params</a> &amp;old)</td></tr>
<tr class="memdesc:a5c3410d5df67dd4c00366caa45a4db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a5c3410d5df67dd4c00366caa45a4db2d">More...</a><br/></td></tr>
<tr class="separator:a5c3410d5df67dd4c00366caa45a4db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb3f8b0f585a3d5f326b63482d744f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22fb3f8b0f585a3d5f326b63482d744f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a22fb3f8b0f585a3d5f326b63482d744f">clear</a> ()</td></tr>
<tr class="memdesc:a22fb3f8b0f585a3d5f326b63482d744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements, including deleting reference to global param sets. <br/></td></tr>
<tr class="separator:a22fb3f8b0f585a3d5f326b63482d744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9cc17544aa35afcacaf48128540f7b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#aba9cc17544aa35afcacaf48128540f7b">count</a> (const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:aba9cc17544aa35afcacaf48128540f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the number of elements with given key.  <a href="#aba9cc17544aa35afcacaf48128540f7b">More...</a><br/></td></tr>
<tr class="separator:aba9cc17544aa35afcacaf48128540f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32d06a7d2ba6a037dcff14e36365397"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac32d06a7d2ba6a037dcff14e36365397"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; not <br class="typebreak"/>
std::is_same&lt; std::string, T &gt;<br class="typebreak"/>
::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#ac32d06a7d2ba6a037dcff14e36365397">find</a> (const std::string &amp;k, T default_value, bool &amp;found) const </td></tr>
<tr class="memdesc:ac32d06a7d2ba6a037dcff14e36365397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#ac32d06a7d2ba6a037dcff14e36365397">More...</a><br/></td></tr>
<tr class="separator:ac32d06a7d2ba6a037dcff14e36365397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767771bb4f25854db66df11b4b35e8e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a767771bb4f25854db66df11b4b35e8e2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a767771bb4f25854db66df11b4b35e8e2">find</a> (const std::string &amp;k, const std::string &amp;default_value, bool &amp;found) const </td></tr>
<tr class="memdesc:a767771bb4f25854db66df11b4b35e8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#a767771bb4f25854db66df11b4b35e8e2">More...</a><br/></td></tr>
<tr class="separator:a767771bb4f25854db66df11b4b35e8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280fda62621ae67a1fbe90d623c231f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a280fda62621ae67a1fbe90d623c231f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same<br class="typebreak"/>
&lt; bool, T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a280fda62621ae67a1fbe90d623c231f3">find</a> (const std::string &amp;k, const char *default_value, bool &amp;found) const </td></tr>
<tr class="memdesc:a280fda62621ae67a1fbe90d623c231f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#a280fda62621ae67a1fbe90d623c231f3">More...</a><br/></td></tr>
<tr class="separator:a280fda62621ae67a1fbe90d623c231f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f891587c134406a842f3dc3f6af2aa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af9f891587c134406a842f3dc3f6af2aa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#af9f891587c134406a842f3dc3f6af2aa">find</a> (const std::string &amp;k, T default_value) const </td></tr>
<tr class="memdesc:af9f891587c134406a842f3dc3f6af2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#af9f891587c134406a842f3dc3f6af2aa">More...</a><br/></td></tr>
<tr class="separator:af9f891587c134406a842f3dc3f6af2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cac84ad973428c70fcba5966f3d017"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a57cac84ad973428c70fcba5966f3d017"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a57cac84ad973428c70fcba5966f3d017">find</a> (const std::string &amp;k, const std::string &amp;default_value) const </td></tr>
<tr class="memdesc:a57cac84ad973428c70fcba5966f3d017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#a57cac84ad973428c70fcba5966f3d017">More...</a><br/></td></tr>
<tr class="separator:a57cac84ad973428c70fcba5966f3d017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd8849725b323525f4fad9dfd9754b5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aafd8849725b323525f4fad9dfd9754b5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same<br class="typebreak"/>
&lt; bool, T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#aafd8849725b323525f4fad9dfd9754b5">find</a> (const std::string &amp;k, const char *default_value) const </td></tr>
<tr class="memdesc:aafd8849725b323525f4fad9dfd9754b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#aafd8849725b323525f4fad9dfd9754b5">More...</a><br/></td></tr>
<tr class="separator:aafd8849725b323525f4fad9dfd9754b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d7c51973c1df5cc8911cee6c366bb0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a33d7c51973c1df5cc8911cee6c366bb0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a33d7c51973c1df5cc8911cee6c366bb0">find</a> (const std::string &amp;k) const </td></tr>
<tr class="memdesc:a33d7c51973c1df5cc8911cee6c366bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#a33d7c51973c1df5cc8911cee6c366bb0">More...</a><br/></td></tr>
<tr class="separator:a33d7c51973c1df5cc8911cee6c366bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e892f1a3fdbf45cc0d428e7770526c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08e892f1a3fdbf45cc0d428e7770526c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; not <br class="typebreak"/>
std::is_same&lt; bool, T &gt;::value, <br class="typebreak"/>
T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a08e892f1a3fdbf45cc0d428e7770526c">find</a> (const std::string &amp;k, bool &amp;found) const </td></tr>
<tr class="memdesc:a08e892f1a3fdbf45cc0d428e7770526c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a type T.  <a href="#a08e892f1a3fdbf45cc0d428e7770526c">More...</a><br/></td></tr>
<tr class="separator:a08e892f1a3fdbf45cc0d428e7770526c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92f670b8d64ca7eb012e5eaf51576a1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae92f670b8d64ca7eb012e5eaf51576a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#ae92f670b8d64ca7eb012e5eaf51576a1">find_array</a> (const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;k, std::vector&lt; T &gt; &amp;vec) const </td></tr>
<tr class="memdesc:ae92f670b8d64ca7eb012e5eaf51576a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a Parameter value in the set, and return its value as a vector of T's.  <a href="#ae92f670b8d64ca7eb012e5eaf51576a1">More...</a><br/></td></tr>
<tr class="separator:ae92f670b8d64ca7eb012e5eaf51576a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e9d55ab7afc38c988ab6990590eb8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a73e9d55ab7afc38c988ab6990590eb8e">is_value_array</a> (const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a73e9d55ab7afc38c988ab6990590eb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the value associated with the given key is considered to be an array.  <a href="#a73e9d55ab7afc38c988ab6990590eb8e">More...</a><br/></td></tr>
<tr class="separator:a73e9d55ab7afc38c988ab6990590eb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1816d7634f049881368e0d00fb5aec5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1816d7634f049881368e0d00fb5aec5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a1816d7634f049881368e0d00fb5aec5c">print_all_params</a> (std::ostream &amp;os, const std::string &amp;prefix=&quot;&quot;) const </td></tr>
<tr class="memdesc:a1816d7634f049881368e0d00fb5aec5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all key/value parameter pairs to specified ostream. <br/></td></tr>
<tr class="separator:a1816d7634f049881368e0d00fb5aec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70ceaa7c602f90ea5dffdc214f1c656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa70ceaa7c602f90ea5dffdc214f1c656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#aa70ceaa7c602f90ea5dffdc214f1c656">print_all_params</a> (<a class="el" href="classSST_1_1Output.html">Output</a> &amp;out, const std::string &amp;prefix=&quot;&quot;) const </td></tr>
<tr class="memdesc:aa70ceaa7c602f90ea5dffdc214f1c656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all key/value parameter pairs to specified ostream. <br/></td></tr>
<tr class="separator:aa70ceaa7c602f90ea5dffdc214f1c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa985bf7b8fe6b8843e68f2c55873a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#afa985bf7b8fe6b8843e68f2c55873a1e">insert</a> (const std::string &amp;key, const std::string &amp;value, bool overwrite=true)</td></tr>
<tr class="memdesc:afa985bf7b8fe6b8843e68f2c55873a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a key/value pair into the param object.  <a href="#afa985bf7b8fe6b8843e68f2c55873a1e">More...</a><br/></td></tr>
<tr class="separator:afa985bf7b8fe6b8843e68f2c55873a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6891d92724e13476aae96605b8712955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a6891d92724e13476aae96605b8712955">insert</a> (const <a class="el" href="classSST_1_1Params.html">Params</a> &amp;params)</td></tr>
<tr class="memdesc:a6891d92724e13476aae96605b8712955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add contents of input <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object to current <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object.  <a href="#a6891d92724e13476aae96605b8712955">More...</a><br/></td></tr>
<tr class="separator:a6891d92724e13476aae96605b8712955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b0bbfd38d21b4de097a9859a18ea49"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a29b0bbfd38d21b4de097a9859a18ea49">getKeys</a> () const </td></tr>
<tr class="memdesc:a29b0bbfd38d21b4de097a9859a18ea49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the keys contained in the <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object.  <a href="#a29b0bbfd38d21b4de097a9859a18ea49">More...</a><br/></td></tr>
<tr class="separator:a29b0bbfd38d21b4de097a9859a18ea49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d420eca81af849b1073a597768fdf24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSST_1_1Params.html">Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a4d420eca81af849b1073a597768fdf24">get_scoped_params</a> (const std::string &amp;scope) const </td></tr>
<tr class="memdesc:a4d420eca81af849b1073a597768fdf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new parameter object with parameters that match the specified scoped prefix (scopes are separated with "." The keys will be stripped of the "scope." prefix.  <a href="#a4d420eca81af849b1073a597768fdf24">More...</a><br/></td></tr>
<tr class="separator:a4d420eca81af849b1073a597768fdf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a63c7d7006c466efa2febf5e740ad3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a63c7d7006c466efa2febf5e740ad3"></a>
<a class="el" href="classSST_1_1Params.html">Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#af5a63c7d7006c466efa2febf5e740ad3">find_prefix_params</a> (const std::string &amp;prefix) const </td></tr>
<tr class="memdesc:af5a63c7d7006c466efa2febf5e740ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new parameter object with parameters that match the specified prefix. <br/></td></tr>
<tr class="separator:af5a63c7d7006c466efa2febf5e740ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0985dcb7c00d9c48ff4d20fadef098ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0985dcb7c00d9c48ff4d20fadef098ff"></a>
<a class="el" href="classSST_1_1Params.html">Params</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_scoped_params</b> (const std::string &amp;scope, const char *delims=&quot;.:&quot;) const </td></tr>
<tr class="separator:a0985dcb7c00d9c48ff4d20fadef098ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c93af0a100992491034b1a6d5b36b95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a1c93af0a100992491034b1a6d5b36b95">contains</a> (const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;k) const </td></tr>
<tr class="memdesc:a1c93af0a100992491034b1a6d5b36b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the container for a particular key.  <a href="#a1c93af0a100992491034b1a6d5b36b95">More...</a><br/></td></tr>
<tr class="separator:a1c93af0a100992491034b1a6d5b36b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb52f8040d931841733adf03185182a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a8cb52f8040d931841733adf03185182a">pushAllowedKeys</a> (const <a class="el" href="classSST_1_1Params.html#aca6800309a3de9d1c6ca038788cdd9af">KeySet_t</a> &amp;keys)</td></tr>
<tr class="separator:a8cb52f8040d931841733adf03185182a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fcc62f728d6e833e2179061195cef5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00fcc62f728d6e833e2179061195cef5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a00fcc62f728d6e833e2179061195cef5">popAllowedKeys</a> ()</td></tr>
<tr class="memdesc:a00fcc62f728d6e833e2179061195cef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the most recent set of keys considered allowed. <br/></td></tr>
<tr class="separator:a00fcc62f728d6e833e2179061195cef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea90d53d7cfa0aab6eef32c2bb372ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#adea90d53d7cfa0aab6eef32c2bb372ec">verifyParam</a> (const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;k) const </td></tr>
<tr class="separator:adea90d53d7cfa0aab6eef32c2bb372ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f900e9e2769e801f963d1b8d0cf481a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a1f900e9e2769e801f963d1b8d0cf481a">addGlobalParamSet</a> (const std::string &amp;set)</td></tr>
<tr class="memdesc:a1f900e9e2769e801f963d1b8d0cf481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a global param set to be looked at in this <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object if the key isn't found locally.  <a href="#a1f900e9e2769e801f963d1b8d0cf481a">More...</a><br/></td></tr>
<tr class="separator:a1f900e9e2769e801f963d1b8d0cf481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae69d754980482b6b613ecc9ee90455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ae69d754980482b6b613ecc9ee90455"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>serialize_order</b> (<a class="el" href="classSST_1_1Core_1_1Serialization_1_1serializer.html">SST::Core::Serialization::serializer</a> &amp;ser) override</td></tr>
<tr class="separator:a9ae69d754980482b6b613ecc9ee90455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSST_1_1Core_1_1Serialization_1_1serializable.html">SST::Core::Serialization::serializable</a></td></tr>
<tr class="memitem:adf9a0dbac8df2c510a9b8b0ab0c8d737 inherit pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf9a0dbac8df2c510a9b8b0ab0c8d737"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cls_name</b> () const =0</td></tr>
<tr class="separator:adf9a0dbac8df2c510a9b8b0ab0c8d737 inherit pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac720f4ed6213cfe616236b4dbfc6a486 inherit pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac720f4ed6213cfe616236b4dbfc6a486"></a>
virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cls_id</b> () const =0</td></tr>
<tr class="separator:ac720f4ed6213cfe616236b4dbfc6a486 inherit pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2c094562161e3ab83817dcaf60be3e inherit pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e2c094562161e3ab83817dcaf60be3e"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>serialization_name</b> () const =0</td></tr>
<tr class="separator:a8e2c094562161e3ab83817dcaf60be3e inherit pub_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a911dbcd34f6555ea1fe9566ae5a2ef2a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#a911dbcd34f6555ea1fe9566ae5a2ef2a">enableVerify</a> ()</td></tr>
<tr class="memdesc:a911dbcd34f6555ea1fe9566ae5a2ef2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable, on a global scale, parameter verification.  <a href="#a911dbcd34f6555ea1fe9566ae5a2ef2a">More...</a><br/></td></tr>
<tr class="separator:a911dbcd34f6555ea1fe9566ae5a2ef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6561f225d0529aee7992cee48f73fb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSST_1_1Params.html#ab6561f225d0529aee7992cee48f73fb2">insert_global</a> (const std::string &amp;set, const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;key, const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;value, bool overwrite=true)</td></tr>
<tr class="memdesc:ab6561f225d0529aee7992cee48f73fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key/value pair to the specified global set.  <a href="#ab6561f225d0529aee7992cee48f73fb2">More...</a><br/></td></tr>
<tr class="separator:ab6561f225d0529aee7992cee48f73fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classSST_1_1Core_1_1Serialization_1_1serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classSST_1_1Core_1_1Serialization_1_1serializable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classSST_1_1Core_1_1Serialization_1_1serializable.html">SST::Core::Serialization::serializable</a></td></tr>
<tr class="memitem:abd91ccbdbad388bdeb8e3bf5ad58ebde inherit pub_static_attribs_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd91ccbdbad388bdeb8e3bf5ad58ebde"></a>
static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>NullClsId</b> = std::numeric_limits&lt;uint32_t&gt;::max()</td></tr>
<tr class="separator:abd91ccbdbad388bdeb8e3bf5ad58ebde inherit pub_static_attribs_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classSST_1_1Core_1_1Serialization_1_1serializable"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classSST_1_1Core_1_1Serialization_1_1serializable')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classSST_1_1Core_1_1Serialization_1_1serializable.html">SST::Core::Serialization::serializable</a></td></tr>
<tr class="memitem:a9c464303ed25775943dc102da901d0b9 inherit pro_types_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>cxn_flag_t</b> { <b>ConstructorFlag</b>
 }</td></tr>
<tr class="separator:a9c464303ed25775943dc102da901d0b9 inherit pro_types_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classSST_1_1Core_1_1Serialization_1_1serializable')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classSST_1_1Core_1_1Serialization_1_1serializable.html">SST::Core::Serialization::serializable</a></td></tr>
<tr class="memitem:a603638ac98966fa80357acad49f74ef1 inherit pro_static_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a603638ac98966fa80357acad49f74ef1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>serializable_abort</b> (uint32_t line, const char *file, const char *func, const char *obj)</td></tr>
<tr class="separator:a603638ac98966fa80357acad49f74ef1 inherit pro_static_methods_classSST_1_1Core_1_1Serialization_1_1serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parameter store. </p>
<p>Stores key-value pairs as std::strings and provides a templated find method for finding values and converting them to arbitrary types (</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classSST_1_1Params.html#ac32d06a7d2ba6a037dcff14e36365397" title="Find a Parameter value in the set, and return its value as a type T. ">find()</a>). </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1becebbd2a5e743425c52699a888285d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::string <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">SST::Params::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of key (string) </p>

</div>
</div>
<a class="anchor" id="aca6800309a3de9d1c6ca038788cdd9af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a>, KeyCompare&gt; <a class="el" href="classSST_1_1Params.html#aca6800309a3de9d1c6ca038788cdd9af">SST::Params::KeySet_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a set of keys </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1f900e9e2769e801f963d1b8d0cf481a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::addGlobalParamSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a global param set to be looked at in this <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object if the key isn't found locally. </p>
<p>It will search the global sets in the order they were inserted and return immediately after finding the key in one of the sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>set to add to the search list for this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c93af0a100992491034b1a6d5b36b95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SST::Params::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the container for a particular key. </p>
<p>This will search both local and global params.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the params contains the key, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aba9cc17544aa35afcacaf48128540f7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SST::Params::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the number of elements with given key. </p>
<p>The call will check both local and global params, but will still only report one instance if the given key is found in both the local and global param sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key (either 1 or 0). </dd></dl>

</div>
</div>
<a class="anchor" id="a2a75c3571c53b300facb15c120bb551c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SST::Params::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> is empty. </p>
<p>Checks both local and global param sets.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object is empty, false otherwise </dd></dl>

<p>References <a class="el" href="classSST_1_1Params.html#a29b0bbfd38d21b4de097a9859a18ea49">getKeys()</a>.</p>

</div>
</div>
<a class="anchor" id="a5078fe8ed23d69bc278f7cdd3414a06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SST::Params::enableVerify </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable parameter verification on an instance of <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a>. </p>
<p>Useful when generating a new set of <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> to pass off to a module.</p>
<dl class="section return"><dt>Returns</dt><dd>returns the previous state of the flag </dd></dl>

<p>Referenced by <a class="el" href="classSST_1_1Params.html#af5a63c7d7006c466efa2febf5e740ad3">find_prefix_params()</a>, and <a class="el" href="classSST_1_1Params.html#a4d420eca81af849b1073a597768fdf24">get_scoped_params()</a>.</p>

</div>
</div>
<a class="anchor" id="a911dbcd34f6555ea1fe9566ae5a2ef2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SST::Params::enableVerify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable, on a global scale, parameter verification. </p>
<p>Used after construction of the config graph so that warnings are not generated during construction. </p>

</div>
</div>
<a class="anchor" id="ac32d06a7d2ba6a037dcff14e36365397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;not std::is_same&lt;std::string,T&gt;::value, T&gt;::type SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>Type T must be either a basic numeric type (including bool) , a std::string, or a class that has a constructor with a std::string as its only parameter. This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>- Default value to return if parameter isn't found </td></tr>
    <tr><td class="paramname">found</td><td>- set to true if the the parameter was found </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If value in (key, value) can't be converted to type T, an invalid_argument exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classSST_1_1Statistics_1_1StatisticOutputJSON.html#a7a0169628951ecb97f94309910b714eb">SST::Statistics::StatisticOutputJSON::checkOutputParameters()</a>, <a class="el" href="classSST_1_1Statistics_1_1StatisticOutputConsole.html#aa24b3af325aea6af5cade6f658682e21">SST::Statistics::StatisticOutputConsole::checkOutputParameters()</a>, <a class="el" href="classSST_1_1Statistics_1_1StatisticOutputTxt.html#ab557c03a6e41517b747aa0777fedad4a">SST::Statistics::StatisticOutputTxt::checkOutputParameters()</a>, <a class="el" href="classSST_1_1Statistics_1_1StatisticOutputCSV.html#a783c9dbbfe6595ab273b25b81d5feaee">SST::Statistics::StatisticOutputCSV::checkOutputParameters()</a>, and <a class="el" href="classSST_1_1Statistics_1_1StatisticBase.html#a15ff4a835d375efed4771332c6a82bd8">SST::Statistics::StatisticBase::StatisticBase()</a>.</p>

</div>
</div>
<a class="anchor" id="a767771bb4f25854db66df11b4b35e8e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>Type T must be either a basic numeric type (including bool) , a std::string, or a class that has a constructor with a std::string as its only parameter. This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>- Default value to return if parameter isn't found, specified as a string </td></tr>
    <tr><td class="paramname">found</td><td>- set to true if the the parameter was found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a280fda62621ae67a1fbe90d623c231f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;bool,T&gt;::value, T&gt;::type SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>This version of find is only enabled for bool. This is required because a string literal will be preferentially cast to a bool rather than a string. This ensures that find&lt;bool&gt; works correctly for string literals. This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>- Default value to return if parameter isn't found, specified as a string literal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9f891587c134406a842f3dc3f6af2aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>Type T must be either a basic numeric type (including bool), a std::string, or a class that has a constructor with a std::string as its only parameter. This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>- Default value to return if parameter isn't found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57cac84ad973428c70fcba5966f3d017"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>Type T must be either a basic numeric type (including bool) , a std::string, or a class that has a constructor with a std::string as its only parameter. This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>- Default value to return if parameter isn't found, specified as a string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafd8849725b323525f4fad9dfd9754b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;bool,T&gt;::value, T&gt;::type SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>This version of find is only enabled for bool. This is required because a string literal will be preferentially cast to a bool rather than a string. This ensures that find&lt;bool&gt; works correctly for string literals.This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>- Default value to return if parameter isn't found, specified as a string literal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33d7c51973c1df5cc8911cee6c366bb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>Type T must be either a basic numeric type (including bool) , a std::string, or a class that has a constructor with a std::string as its only parameter. This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08e892f1a3fdbf45cc0d428e7770526c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;not std::is_same&lt;bool, T&gt;::value, T&gt;::type SST::Params::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a type T. </p>
<p>Type T must be either a basic numeric type , a std::string, or a class that has a constructor with a std::string as its only parameter. This version of find is not enabled for bool as it conflicts with find&lt;bool&gt;(string key, bool default_value). This class uses SST::Core::from_string to do the conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">found</td><td>- set to true if the the parameter was found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae92f670b8d64ca7eb012e5eaf51576a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::find_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a Parameter value in the set, and return its value as a vector of T's. </p>
<p>The array will be appended to the end of the vector.</p>
<p>Type T must be either a basic numeric type (including bool) , a std::string, or a class that has a constructor with a std::string as its only parameter. This class uses SST::Core::from_string to do the conversion. The values in the array must be enclosed in square brackets ( [] ), and be comma separated (commas in double or single quotes will not be considered a delimiter). If there are no square brackets, the entire string will be considered one value and a single item will be added to the vector.</p>
<p>More details about parsing the values out of the string:</p>
<p>Parses a string representing an array of tokens. It is tailored to the types strings you get when passing a python list as the param string. When you call addParam() on a python list in the input file, it will call the str() function on the list, which creates a string with the following format: [item1, item2, item3]</p>
<p>The format of the items depends on where they came from. The string for the items are generated by calling the repr() function on them. For strings, this means they will typically be enclosed in single quotes. It is possible that they end up enclosed in double quotes if the string itself contains a single quote. For strings which contain both single and double quotes, the repr() will create a single quoted string with all internal single quotes escaped with '\'. Most other items used in SST do not enclose the string in quotes, though any string that contains a comma would need to be enclosed in quotes, since the comma is the delimiter character used. This is not done automatically, so if you have something that generates a commma in the string created by repr(), you may need to create an array string manually. Also, any string that starts with a quote character, must end with the same quote character.</p>
<p>Tokens are generated by splitting the string on commas that are not within quotes (double or single). All whitespace at the beginning and end of a token is ignored (unless inside quotes). Once the tokens are generated, any quoted string will have the front and back quotes removed. The '\' for any escaped quote of the same type as the front and back is also removed.</p>
<p>Examples:</p>
<p>These will produce the same results: [1, 2, 3, 4, 5] ['1', '2', '3', '4', '5']</p>
<p>Examples of strings using double and/or single quotes: 'This is "a" test' -&gt; This is "a" test "This is 'a' test" -&gt; This is 'a' test 'This "is \'a\'" test' -&gt; This "is 'a'" test 'This "is \"a"" test'  -&gt; This "is "a"" test</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
    <tr><td class="paramname">vec</td><td>- vector to append array items to </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classSST_1_1Params.html#adea90d53d7cfa0aab6eef32c2bb372ec">verifyParam()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d420eca81af849b1073a597768fdf24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSST_1_1Params.html">Params</a> SST::Params::get_scoped_params </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new parameter object with parameters that match the specified scoped prefix (scopes are separated with "." The keys will be stripped of the "scope." prefix. </p>
<p>Function will search both local and global params, but all params will be copied into the local space of the new <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Scope to search (anything prefixed with "scope." will be included in the return <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object with the found scoped params. </dd></dl>

<p>References <a class="el" href="classSST_1_1Params.html#a5078fe8ed23d69bc278f7cdd3414a06f">enableVerify()</a>, and <a class="el" href="classSST_1_1Params.html#afa985bf7b8fe6b8843e68f2c55873a1e">insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a29b0bbfd38d21b4de097a9859a18ea49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; SST::Params::getKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the keys contained in the <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object. </p>
<p>This will give both local and global params. </p>

<p>Referenced by <a class="el" href="classSST_1_1Params.html#a2a75c3571c53b300facb15c120bb551c">empty()</a>, and <a class="el" href="classSST_1_1Params.html#a1177506a58aa634ad786333da58aaf61">size()</a>.</p>

</div>
</div>
<a class="anchor" id="afa985bf7b8fe6b8843e68f2c55873a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a key/value pair into the param object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to add to the map</td></tr>
    <tr><td class="paramname">value</td><td>value to add to the map</td></tr>
    <tr><td class="paramname">overwrite</td><td>controls whether the key/value pair will overwrite an existing pair in the set </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classSST_1_1ConfigGraph.html#a91d156aeed4fd1c6d43466889e289267">SST::ConfigGraph::addStatisticOutputParameter()</a>, <a class="el" href="classSST_1_1Params.html#af5a63c7d7006c466efa2febf5e740ad3">find_prefix_params()</a>, and <a class="el" href="classSST_1_1Params.html#a4d420eca81af849b1073a597768fdf24">get_scoped_params()</a>.</p>

</div>
</div>
<a class="anchor" id="a6891d92724e13476aae96605b8712955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html">Params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add contents of input <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object to current <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object. </p>
<p>This will also add any pointers to global param sets after the existing pointers to global param sets in this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td><a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object that should added to current object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6561f225d0529aee7992cee48f73fb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::insert_global </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a key/value pair to the specified global set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>global set to add the key/value pair to</td></tr>
    <tr><td class="paramname">key</td><td>key to add to the map</td></tr>
    <tr><td class="paramname">value</td><td>value to add to the map</td></tr>
    <tr><td class="paramname">overwrite</td><td>controls whether the key/value pair will overwrite an existing pair in the set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73e9d55ab7afc38c988ab6990590eb8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SST::Params::is_value_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if the value associated with the given key is considered to be an array. </p>
<p>A value is considered to be an array if it is enclosed in square brackets ([]). No whitespace before or after the brackets is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- Parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is an array as described above, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3410d5df67dd4c00366caa45a4db2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSST_1_1Params.html">Params</a> &amp; SST::Params::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html">Params</a> &amp;&#160;</td>
          <td class="paramname"><em>old</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old</td><td>Param to be copied</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of old are copied, This will also copy over any references to global param sets </p>

</div>
</div>
<a class="anchor" id="a8cb52f8040d931841733adf03185182a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::pushAllowedKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#aca6800309a3de9d1c6ca038788cdd9af">KeySet_t</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Set of keys to consider valid to add to the stack of legal keys </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classSST_1_1Factory.html#a9dc729fde933cfadf872ffdf000de92b">SST::Factory::Create()</a>, <a class="el" href="classSST_1_1Factory.html#a3fb903a59bd74e06a5beade1ae54883b">SST::Factory::CreateComponent()</a>, <a class="el" href="classSST_1_1Factory.html#ad64f0d2747410e8148aaeeb389b8529f">SST::Factory::CreateModule()</a>, and <a class="el" href="classSST_1_1Factory.html#a1de93423793243f5646c241643183bcc">SST::Factory::CreateModuleWithComponent()</a>.</p>

</div>
</div>
<a class="anchor" id="a1177506a58aa634ad786333da58aaf61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SST::Params::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a>. </p>
<p>This will count both local and global params.</p>
<dl class="section return"><dt>Returns</dt><dd>number of key/value pairs in this <a class="el" href="classSST_1_1Params.html" title="Parameter store. ">Params</a> object </dd></dl>

<p>References <a class="el" href="classSST_1_1Params.html#a29b0bbfd38d21b4de097a9859a18ea49">getKeys()</a>.</p>

</div>
</div>
<a class="anchor" id="adea90d53d7cfa0aab6eef32c2bb372ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SST::Params::verifyParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSST_1_1Params.html#a1becebbd2a5e743425c52699a888285d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to check for validity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key is considered allowed </dd></dl>

<p>References <a class="el" href="classSST_1_1Output.html#ac19d2a95376b685b3b2015aac50f15b0">SST::Output::output()</a>, and <a class="el" href="classSST_1_1Output.html#a76de57b1c8e82fe0b91f2fac3b8d6558a2af091fd10dca7957a147955e9c686a2">SST::Output::STDERR</a>.</p>

<p>Referenced by <a class="el" href="classSST_1_1Params.html#ae92f670b8d64ca7eb012e5eaf51576a1">find_array()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/sst/core/<a class="el" href="params_8h_source.html">params.h</a></li>
<li>src/sst/core/params.cc</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>SST</b></li><li class="navelem"><a class="el" href="classSST_1_1Params.html">Params</a></li>
    <li class="footer">Generated on Mon May 3 2021 09:45:08 for SST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
